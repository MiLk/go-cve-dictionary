package jvn

import (
	"encoding/xml"
	"fmt"
	"strings"
	"time"

	"github.com/kotakanbe/go-cve-dictionary/fetcher"
	log "github.com/kotakanbe/go-cve-dictionary/log"
	"github.com/kotakanbe/go-cve-dictionary/models"
)

type rdf struct {
	Items []Item `xml:"item"`
}

// Item ... http://jvndb.jvn.jp/apis/getVulnOverviewList_api.html
type Item struct {
	About       string       `xml:"about,attr"`
	Title       string       `xml:"title"`
	Link        string       `xml:"link"`
	Description string       `xml:"description"`
	Publisher   string       `xml:"publisher"`
	Identifier  string       `xml:"identifier"`
	References  []references `xml:"references"`
	CpeItem     []cpeItem    `xml:"cpe-item"`
	Cvss        Cvss         `xml:"cvss"`
	Date        string       `xml:"date"`
	Issued      string       `xml:"issued"`
	Modified    string       `xml:"modified"`
}

type cpeItem struct {
	// cpe:/a:mysql:mysql
	Name string `xml:"name,attr"`
	// MySQL
	Title string `xml:"title"`
	// MySQL AB
	Vname string `xml:"vname"`
}

type references struct {
	ID     string `xml:"id,attr"`
	Source string `xml:"source,attr"`
	URL    string `xml:",chardata"`
}

// Cvss ... CVSS
type Cvss struct {
	Score    string `xml:"score,attr"`
	Severity string `xml:"severity,attr"`
	Vector   string `xml:"vector,attr"`
	Version  string `xml:"version,attr"`
}

// FetchJvn fetches vulnerability information from JVN
func FetchJvn(years []int) (cves []models.CveDetail, err error) {
	reqs := []fetcher.FetchRequest{}
	for _, url := range makeJvnURLs(years) {
		reqs = append(reqs, fetcher.FetchRequest{
			URL: url,
		})
	}

	results, err := fetcher.FetchFeedFiles(reqs)
	if err != nil {
		return nil,
			fmt.Errorf("Failed to fetch. err: %s", err)
	}

	for _, res := range results {
		var rdf rdf
		if err = xml.Unmarshal([]byte(res.Body), &rdf); err != nil {
			return nil, fmt.Errorf(
				"Failed to unmarshal. url: %s, err: %s", res.URL, err)
		}
		for _, item := range rdf.Items {
			converted, err := convertToModel(item)
			if err != nil {
				return nil, fmt.Errorf("Failed to convert to model. JVN: %s, err: %s",
					item.Identifier, err)
			}
			cves = append(cves, converted...)
		}
	}
	return
}

func makeJvnURLs(years []int) (urls []string) {
	latestFeeds := []string{
		"http://jvndb.jvn.jp/ja/rss/jvndb_new.rdf",
		"http://jvndb.jvn.jp/ja/rss/jvndb.rdf",
	}

	if len(years) == 0 {
		return latestFeeds
	}

	urlFormat := "http://jvndb.jvn.jp/ja/rss/years/jvndb_%d.rdf"
	for _, year := range years {
		urls = append(urls, fmt.Sprintf(urlFormat, year))

		thisYear := time.Now().Year()
		if year == thisYear {
			urls = append(urls, latestFeeds...)
		}
	}
	return
}

// ConvertJvn converts Jvn structure(got from JVN) to model structure.
func convertToModel(item Item) (cves []models.CveDetail, err error) {
	if item.Cvss.Score == "0" || len(item.Cvss.Score) == 0 {
		log.Debugf("Skip. CVSS Score is zero. JvnID: %s", item.Identifier)
		//ignore invalid item
		return nil, nil
	}

	//  References
	refs := []models.Reference{}
	for _, r := range item.References {
		ref := models.Reference{
			Source: r.Source,
			Link:   r.URL,
		}
		refs = append(refs, ref)
	}

	// Cpes
	cpes := []models.Cpe{}
	for _, c := range item.CpeItem {
		cpeBase, err := fetcher.ParseCpeURI(c.Name)
		if err != nil {
			return nil, err
		}
		cpes = append(cpes, models.Cpe{
			CpeBase: *cpeBase,
		})
	}

	publish, err := parseJvnTime(item.Issued)
	if err != nil {
		return nil, err
	}
	modified, err := parseJvnTime(item.Modified)
	if err != nil {
		return nil, err
	}

	cveIDs := getCveIDs(item)
	if len(cveIDs) == 0 {
		log.Debugf("No CveIDs in references. JvnID: %s, Link: %s",
			item.Identifier, item.Link)
		// ignore this item
		return nil, nil

	}

	for _, cveID := range cveIDs {
		cve := models.CveDetail{
			CveID: cveID,

			Jvn: &models.Jvn{
				CveID:   cveID,
				Title:   strings.Replace(item.Title, "\r", "", -1),
				Summary: strings.Replace(item.Description, "\r", "", -1),
				JvnLink: item.Link,
				JvnID:   item.Identifier,

				Cvss2: models.Cvss2{
					BaseScore:    fetcher.StringToFloat(item.Cvss.Score),
					Severity:     item.Cvss.Severity,
					VectorString: item.Cvss.Vector,
					// TODO extract vectorstring to each fields
				},

				References: refs,
				Cpes:       cpes,

				PublishedDate:    publish,
				LastModifiedDate: modified,
			},
		}
		cves = append(cves, cve)
	}
	return
}

// convert string time to time.Time
// JVN : "2016-01-26T13:36:23+09:00",
// NVD : "2016-01-20T21:59:01.313-05:00",
func parseJvnTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04-07:00"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, fmt.Errorf("Failed to parse time, time: %s, err: %s",
			strtime, err)
	}
	return
}

func getCveIDs(item Item) []string {
	cveIDsMap := map[string]bool{}
	for _, ref := range item.References {
		switch ref.Source {
		case "NVD", "CVE":
			cveIDsMap[ref.ID] = true
		}
	}
	var cveIDs []string
	for cveID := range cveIDsMap {
		cveIDs = append(cveIDs, cveID)
	}
	return cveIDs
}
