package db

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/cheggaaa/pb"
	"github.com/go-redis/redis"
	c "github.com/kotakanbe/go-cve-dictionary/config"
	jvn "github.com/kotakanbe/go-cve-dictionary/fetcher/jvn/xml"
	nvdjson "github.com/kotakanbe/go-cve-dictionary/fetcher/nvd/json"
	nvd "github.com/kotakanbe/go-cve-dictionary/fetcher/nvd/xml"
	log "github.com/kotakanbe/go-cve-dictionary/log"
	"github.com/kotakanbe/go-cve-dictionary/models"
)

/**
# Redis Data Structure

- HASH
  ┌────────────┬──────────┬──────────┬─────────────────────────────────┐
  │    HASH    │  FIELD   │  VALUE   │             PURPOSE             │
  └────────────┴──────────┴──────────┴─────────────────────────────────┘
  ┌────────────┬──────────┬──────────┬─────────────────────────────────┐
  │CVE#${CVEID}│NVD or JVN│${CVEJSON}│Get CVEJSON by CVEID             │
  ├────────────┼──────────┼──────────┼─────────────────────────────────┤
  │  CVE#Cpe   │${CPENAME}│${CPEJSON}│Get CPEJSON BY CPE name          │
  └────────────┴──────────┴──────────┴─────────────────────────────────┘

- ZINDE  X
  ┌─────────────────────────┬──────────┬────────────┬─────────────────────────────────────┐
  │       KEY               │  SCORE   │  MEMBER    │             PURPOSE                 │
  └─────────────────────────┴──────────┴────────────┴─────────────────────────────────────┘
  ┌─────────────────────────┬──────────┬────────────┬─────────────────────────────────────┐
  │CVE#${CPENAME}           │    0     │[]${CVEID}  │Get related []CVEID by CpeName       │
  ├─────────────────────────┼──────────┼────────────┼─────────────────────────────────────┤
  │CVE#${Vendor}            │    0     │[]${CVEID}  │Get related []CVEID by Vendor        │
  ├─────────────────────────┼──────────┼────────────┼─────────────────────────────────────┤
  │CVE#${Vendor}::${Product}│    0     │[]${CVEID}  │Get related []CVEID by Vendor,Product│
  ├─────────────────────────┼──────────┼────────────┼─────────────────────────────────────┤
  │CVE#CpeName              │    0     │[]${CPENAME}│Get all CpeName                      │
  └─────────────────────────┴──────────┴────────────┴─────────────────────────────────────┘

**/

const (
	dialectRedis  = "redis"
	hashKeyPrefix = "CVE#"
)

// RedisDriver is Driver for Redis
type RedisDriver struct {
	name string
	conn *redis.Client
}

// Name return db name
func (r *RedisDriver) Name() string {
	return r.name
}

// NewRedis return Redis driver
func NewRedis(dbType, dbpath string, debugSQL bool) (driver *RedisDriver, err error) {
	driver = &RedisDriver{
		name: dbType,
	}
	log.Debugf("Opening DB (%s).", driver.Name())
	if err = driver.OpenDB(dbType, dbpath, debugSQL); err != nil {
		return
	}

	return
}

// OpenDB opens Database
func (r *RedisDriver) OpenDB(dbType, dbPath string, debugSQL bool) (err error) {
	var option *redis.Options
	if option, err = redis.ParseURL(dbPath); err != nil {
		log.Error(err)
		return fmt.Errorf("Failed to Parse Redis URL. dbpath: %s, err: %s", dbPath, err)
	}
	r.conn = redis.NewClient(option)
	if err = r.conn.Ping().Err(); err != nil {
		return fmt.Errorf("Failed to open DB. dbtype: %s, dbpath: %s, err: %s", dbType, dbPath, err)
	}
	return nil
}

// CloseDB close Database
func (r *RedisDriver) CloseDB() (err error) {
	if err = r.conn.Close(); err != nil {
		log.Errorf("Failed to close DB. Type: %s. err: %s", r.name, err)
		return
	}
	return
}

// Get Select Cve information from DB.
func (r *RedisDriver) Get(cveID string) (*models.CveDetail, error) {
	var result *redis.StringStringMapCmd
	if result = r.conn.HGetAll(hashKeyPrefix + cveID); result.Err() != nil {
		return nil, result.Err()
	}
	return r.unmarshal(cveID, result)
}

// GetMulti Select Cves information from DB.
func (r *RedisDriver) GetMulti(cveIDs []string) (map[string]*models.CveDetail, error) {
	cveDetails := map[string]*models.CveDetail{}
	pipe := r.conn.Pipeline()
	rs := map[string]*redis.StringStringMapCmd{}
	for _, cveID := range cveIDs {
		rs[cveID] = pipe.HGetAll(hashKeyPrefix + cveID)
	}
	if _, err := pipe.Exec(); err != nil {
		if err != redis.Nil {
			return nil, fmt.Errorf("Failed to get multi cve json. err : %s", err)
		}
	}

	for cveID, result := range rs {
		cveDetail, err := r.unmarshal(cveID, result)
		if err != nil {
			return nil, err
		}
		cveDetails[cveID] = cveDetail
	}
	return cveDetails, nil
}

func (r *RedisDriver) unmarshal(cveID string, result *redis.StringStringMapCmd) (*models.CveDetail, error) {
	var err error
	jvn := &models.Jvn{}
	if j, ok := result.Val()["Jvn"]; ok {
		if err = json.Unmarshal([]byte(j), jvn); err != nil {
			return nil, err
		}
	}
	if jvn.CveID == "" {
		jvn = nil
	}

	nvd := &models.Nvd{}
	if j, ok := result.Val()["Nvd"]; ok {
		if err = json.Unmarshal([]byte(j), nvd); err != nil {
			return nil, err
		}
	}
	if nvd.CveID == "" {
		nvd = nil
	}

	nvdjson := &models.NvdJSON{}
	if j, ok := result.Val()["NvdJSON"]; ok {
		if err = json.Unmarshal([]byte(j), nvdjson); err != nil {
			return nil, err
		}
	}
	if nvdjson.CveID == "" {
		nvdjson = nil
	}

	return &models.CveDetail{
		CveID:   cveID,
		Nvd:     nvd,
		NvdJSON: nvdjson,
		Jvn:     jvn,
	}, nil
}

// GetByCpeName Select Cve information from DB.
func (r *RedisDriver) GetByCpeName(cpeName string) (details []*models.CveDetail, err error) {
	var result *redis.StringSliceCmd
	if result = r.conn.ZRange(hashKeyPrefix+cpeName, 0, -1); result.Err() != nil {
		return nil, result.Err()
	}

	for _, v := range result.Val() {
		d, err := r.Get(v)
		if err != nil {
			return nil, err
		}
		details = append(details, d)
	}
	return
}

// InsertJvn insert items fetched from JVN.
func (r *RedisDriver) InsertJvn(items []jvn.Item) error {
	log.Info("Inserting fetched CVEs...")
	cves, err := convertJvn(items)
	if err != nil {
		return fmt.Errorf("Failed to convert to model: %s", err)
	}
	return r.insertJvn(cves)
}

// InsertIntoJvn inserts Cve Information into DB
func (r *RedisDriver) insertJvn(cves []models.CveDetail) error {
	var err error
	var refreshedJvns []string
	bar := pb.New(len(cves))
	if c.Conf.Quiet {
		bar.Output = ioutil.Discard
	} else {
		bar.Output = os.Stderr
	}
	bar.Start()

	for chunked := range chunkSlice(cves, 10) {
		var pipe redis.Pipeliner
		pipe = r.conn.Pipeline()
		for _, c := range chunked {
			bar.Increment()

			var jj []byte
			if jj, err = json.Marshal(c.Jvn); err != nil {
				return fmt.Errorf("Failed to marshal json. err: %s", err)
			}
			refreshedJvns = append(refreshedJvns, c.CveID)
			if result := pipe.HSet(hashKeyPrefix+c.CveID, "Jvn", string(jj)); result.Err() != nil {
				return fmt.Errorf("Failed to HSet CVE. err: %s", result.Err())
			}

			//TODO WFN or 23uri, formatted string
			for _, cpe := range c.Jvn.Cpes {
				var jc []byte
				if jc, err = json.Marshal(cpe); err != nil {
					return fmt.Errorf("Failed to marshal json. err: %s", err)
				}

				if result := pipe.HSet(hashKeyPrefix+"Cpe", cpe.URI, jc); result.Err() != nil {
					return fmt.Errorf("Failed to HSet cpe. err: %s", result.Err())
				}
				if result := pipe.ZAdd(
					hashKeyPrefix+cpe.URI,
					redis.Z{Score: 0, Member: c.CveID},
				); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe name. err: %s", result.Err())
				}
				if result := pipe.ZAdd(
					hashKeyPrefix+"CpeName",
					redis.Z{Score: 0, Member: cpe.URI},
				); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe. err: %s", result.Err())
				}
			}
		}
		if _, err = pipe.Exec(); err != nil {
			return fmt.Errorf("Failed to exec pipeline. err: %s", err)
		}
	}
	bar.Finish()
	log.Infof("Refreshed %d Jvns.", len(refreshedJvns))
	//  log.Debugf("%v", refreshedJvns)
	return nil
}

// CountNvd count nvd table
func (r *RedisDriver) CountNvd() (int, error) {
	var result *redis.StringSliceCmd
	if result = r.conn.Keys(hashKeyPrefix + "CVE*"); result.Err() != nil {
		return 0, result.Err()
	}
	return len(result.Val()), nil
}

// InsertNvd inserts CveInformation into DB
func (r *RedisDriver) InsertNvd(entries []nvd.Entry) error {
	log.Info("Inserting CVEs...")
	cves, err := convertNvd(entries)
	if err != nil {
		return fmt.Errorf("Failed to convert to model: %s", err)
	}
	return r.insertNvd(cves)
}

// insertIntoNvd inserts CveInformation into DB
func (r *RedisDriver) insertNvd(cves []models.CveDetail) error {
	var err error
	var refreshedNvds []string
	bar := pb.New(len(cves))
	if c.Conf.Quiet {
		bar.Output = ioutil.Discard
	} else {
		bar.Output = os.Stderr
	}
	bar.Start()

	for chunked := range chunkSlice(cves, 10) {
		var pipe redis.Pipeliner
		pipe = r.conn.Pipeline()
		for _, c := range chunked {
			bar.Increment()

			var jn []byte
			if jn, err = json.Marshal(c.Nvd); err != nil {
				return fmt.Errorf("Failed to marshal json. err: %s", err)
			}
			refreshedNvds = append(refreshedNvds, c.CveID)
			if result := pipe.HSet(hashKeyPrefix+c.CveID, "Nvd", string(jn)); result.Err() != nil {
				return fmt.Errorf("Failed to HSet CVE. err: %s", result.Err())
			}

			//TODO WFN or 23uri, formatted string
			for _, cpe := range c.Nvd.Cpes {
				var jc []byte
				if jc, err = json.Marshal(cpe); err != nil {
					return fmt.Errorf("Failed to marshal json. err: %s", err)
				}

				if result := pipe.HSet(hashKeyPrefix+"Cpe", cpe.URI, jc); result.Err() != nil {
					return fmt.Errorf("Failed to HSet cpe. err: %s", result.Err())
				}
				if result := pipe.ZAdd(
					hashKeyPrefix+cpe.URI,
					redis.Z{Score: 0, Member: c.CveID},
				); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe name. err: %s", result.Err())
				}
				if result := pipe.ZAdd(
					hashKeyPrefix+"CpeName",
					redis.Z{Score: 0, Member: cpe.URI},
				); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe. err: %s", result.Err())
				}
			}
		}
		if _, err = pipe.Exec(); err != nil {
			return fmt.Errorf("Failed to exec pipeline. err: %s", err)
		}
	}
	bar.Finish()

	log.Infof("Refreshed %d Nvds.", len(refreshedNvds))
	//  log.Debugf("%v", refreshedNvds)
	return nil
}

// InsertNvdJSON Cve information from DB.
func (r *RedisDriver) InsertNvdJSON(nvds []nvdjson.NvdJSON) error {
	log.Info("Inserting CVEs...")
	cves, err := convertNvdJSON(nvds)
	if err != nil {
		return fmt.Errorf("Failed to convert to model: %s", err)
	}
	return r.insertNvdJSON(cves)
}

// insertIntoNvd inserts CveInformation into DB
func (r *RedisDriver) insertNvdJSON(cves []models.CveDetail) error {
	var err error
	var refreshedNvds []string
	bar := pb.New(len(cves))
	if c.Conf.Quiet {
		bar.Output = ioutil.Discard
	} else {
		bar.Output = os.Stderr
	}
	bar.Start()

	for chunked := range chunkSlice(cves, 10) {
		var pipe redis.Pipeliner
		pipe = r.conn.Pipeline()
		for _, c := range chunked {
			bar.Increment()

			var jn []byte
			if jn, err = json.Marshal(c.NvdJSON); err != nil {
				return fmt.Errorf("Failed to marshal json. err: %s", err)
			}
			refreshedNvds = append(refreshedNvds, c.CveID)
			if result := pipe.HSet(hashKeyPrefix+c.CveID, "NvdJSON", string(jn)); result.Err() != nil {
				return fmt.Errorf("Failed to HSet CVE. err: %s", result.Err())
			}

			//TODO WFN or 23uri, formatted string
			for _, cpe := range c.NvdJSON.Cpes {
				var jc []byte
				if jc, err = json.Marshal(cpe); err != nil {
					return fmt.Errorf("Failed to marshal json. err: %s", err)
				}
				if result := pipe.HSet(hashKeyPrefix+"Cpe", cpe.FormattedString, jc); result.Err() != nil {
					return fmt.Errorf("Failed to HSet cpe. err: %s", result.Err())
				}
				if result := pipe.ZAdd(
					hashKeyPrefix+cpe.FormattedString,
					redis.Z{Score: 0, Member: c.CveID},
				); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe name. err: %s", result.Err())
				}
				if result := pipe.ZAdd(
					hashKeyPrefix+"CpeName",
					redis.Z{Score: 0, Member: cpe.FormattedString},
				); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe. err: %s", result.Err())
				}

				for _, ecpe := range cpe.EnvCpes {
					if result := pipe.HSet(hashKeyPrefix+"Cpe", ecpe.FormattedString, jc); result.Err() != nil {
						return fmt.Errorf("Failed to HSet cpe. err: %s", result.Err())
					}
					if result := pipe.ZAdd(
						hashKeyPrefix+"CpeName",
						redis.Z{Score: 0, Member: ecpe.FormattedString},
					); result.Err() != nil {
						return fmt.Errorf("Failed to ZAdd cpe. err: %s", result.Err())
					}
				}
			}
		}
		if _, err = pipe.Exec(); err != nil {
			return fmt.Errorf("Failed to exec pipeline. err: %s", err)
		}
	}
	bar.Finish()

	log.Infof("Refreshed %d Nvds.", len(refreshedNvds))
	//  log.Debugf("%v", refreshedNvds)
	return nil
}
