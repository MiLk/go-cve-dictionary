package db

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/k0kubun/pp"
	jvn "github.com/kotakanbe/go-cve-dictionary/fetcher/jvn/xml"
	nvdjson "github.com/kotakanbe/go-cve-dictionary/fetcher/nvd/json"
	nvd "github.com/kotakanbe/go-cve-dictionary/fetcher/nvd/xml"
	log "github.com/kotakanbe/go-cve-dictionary/log"
	"github.com/kotakanbe/go-cve-dictionary/models"

	"github.com/knqyf263/go-cpe/common"
	"github.com/knqyf263/go-cpe/naming"
)

// DB is interface for a database driver
type DB interface {
	Name() string
	CloseDB() error
	Get(string) (*models.CveDetail, error)
	GetMulti([]string) (map[string]*models.CveDetail, error)
	GetByCpeName(string) ([]*models.CveDetail, error)
	InsertJvn([]jvn.Item) error
	InsertNvd([]nvd.Entry) error
	InsertNvdJSON([]nvdjson.NvdJSON) error
	CountNvd() (int, error)
}

// NewDB return DB accessor.
func NewDB(dbType, dbpath string, debugSQL bool) (DB, error) {
	switch dbType {
	case dialectSqlite3, dialectMysql, dialectPostgreSQL:
		return NewRDB(dbType, dbpath, debugSQL)
	case dialectRedis:
		return NewRedis(dbType, dbpath, debugSQL)
	}
	return nil, fmt.Errorf("Invalid database dialect, %s", dbType)
}

// convertNvd converts Nvd structure(got from NVD) to model structure.
func convertNvd(entries []nvd.Entry) (cves []models.CveDetail, err error) {
	for _, entry := range entries {
		refs := []models.Reference{}
		for _, r := range entry.References {
			ref := models.Reference{
				Source: r.Source,
				Link:   r.Link.Href,
			}
			refs = append(refs, ref)
		}

		cpes := []models.Cpe{}
		for _, c := range entry.Products {
			cpeBase, err := parseCpeURI(c)
			if err != nil {
				return nil, err
			}
			cpes = append(cpes, models.Cpe{
				CpeBase: *cpeBase,
			})
		}

		cwes := []models.Cwe{}
		for _, cwe := range entry.Cwes {
			cwes = append(cwes, models.Cwe{
				CweID: cwe.ID,
			})
		}

		cve := models.CveDetail{
			CveID: entry.CveID,
			Nvd: &models.Nvd{
				CveID:   entry.CveID,
				Summary: entry.Summary,
				Cvss2: models.Cvss2{
					//TODO VectorString
					BaseScore:             stringToFloat(entry.Cvss.Score),
					AccessVector:          entry.Cvss.AccessVector,
					AccessComplexity:      entry.Cvss.AccessComplexity,
					Authentication:        entry.Cvss.Authentication,
					ConfidentialityImpact: entry.Cvss.ConfidentialityImpact,
					IntegrityImpact:       entry.Cvss.IntegrityImpact,
					AvailabilityImpact:    entry.Cvss.AvailabilityImpact,
				},
				Cwes:             cwes,
				PublishedDate:    entry.PublishedDate,
				LastModifiedDate: entry.LastModifiedDate,

				Cpes:       cpes,
				References: refs,
			},
		}
		cves = append(cves, cve)
	}
	return
}

// ConvertJvn converts Jvn structure(got from JVN) to model structure.
func convertJvn(items []jvn.Item) (cves []models.CveDetail, err error) {
	for _, item := range items {
		if item.Cvss.Score == "0" || len(item.Cvss.Score) == 0 {
			log.Debugf("Skip. CVSS Score is zero. JvnID: %s", item.Identifier)
			//ignore invalid item
			continue
		}

		//  References
		refs := []models.Reference{}
		for _, r := range item.References {
			ref := models.Reference{
				Source: r.Source,
				Link:   r.URL,
			}
			refs = append(refs, ref)
		}

		// Cpes
		cpes := []models.Cpe{}
		for _, c := range item.CpeItem {
			cpeBase, err := parseCpeURI(c.Name)
			if err != nil {
				return nil, err
			}
			cpes = append(cpes, models.Cpe{
				CpeBase: *cpeBase,
			})
		}

		publish, err := parseJvnTime(item.Issued)
		if err != nil {
			return nil, err
		}
		modified, err := parseJvnTime(item.Modified)
		if err != nil {
			return nil, err
		}

		cveIDs := getCveIDs(item)
		if len(cveIDs) == 0 {
			log.Debugf("No CveIDs in references. JvnID: %s, Link: %s",
				item.Identifier, item.Link)
			// ignore this item
			continue

		}

		for _, cveID := range cveIDs {
			cve := models.CveDetail{
				CveID: cveID,

				Jvn: &models.Jvn{
					CveID:   cveID,
					Title:   strings.Replace(item.Title, "\r", "", -1),
					Summary: strings.Replace(item.Description, "\r", "", -1),
					JvnLink: item.Link,
					JvnID:   item.Identifier,

					Cvss2: models.Cvss2{
						BaseScore:    stringToFloat(item.Cvss.Score),
						Severity:     item.Cvss.Severity,
						VectorString: item.Cvss.Vector,
						// TODO extract vectorstring to each fields
					},

					References: refs,
					Cpes:       cpes,

					PublishedDate:    publish,
					LastModifiedDate: modified,
				},
			}
			cves = append(cves, cve)
		}
	}
	return
}

// convertNvdJSON converts Nvd JSON to model structure.
func convertNvdJSON(nvds []nvdjson.NvdJSON) (cves []models.CveDetail, err error) {
	for _, nvd := range nvds {
		for _, item := range nvd.CveItems {

			//References
			refs := []models.Reference{}
			for _, r := range item.Cve.References.ReferenceData {
				ref := models.Reference{
					Link: r.URL,
				}
				refs = append(refs, ref)
			}

			// Cwes
			cwes := []models.Cwe{}
			for _, data := range item.Cve.Problemtype.ProblemtypeData {
				for _, desc := range data.Description {
					cwes = append(cwes, models.Cwe{
						CweID: desc.Value,
					})
				}
			}

			// Affects
			affects := []models.Affect{}
			for _, vendor := range item.Cve.Affects.Vendor.VendorData {
				for _, prod := range vendor.Product.ProductData {
					for _, version := range prod.Version.VersionData {
						affects = append(affects, models.Affect{
							Vendor:  vendor.VendorName,
							Product: prod.ProductName,
							Version: version.VersionValue,
						})
					}
				}
			}

			// Traverse Cpe, EnvCpe
			cpes := []models.Cpe{}
			for _, node := range item.Configurations.Nodes {
				if node.Negate {
					pp.Printf("Finally found Negate True!!!: %s", item.Cve.CveDataMeta.ID)
					continue
				}

				nodeCpes := []models.Cpe{}
				for _, cpe := range node.Cpes {
					if !cpe.Vulnerable {
						// CVE-2017-14492 and CVE-2017-8581 has a cpe that has vulenrable:false.
						// But these vulnerable: false cpe is also vulnerable...
						// So, ignore the vulerable flag of this layer(under nodes>cpe)
					}
					cpeBase, err := parseCpeURI(cpe.Cpe22URI)
					if err != nil {
						return nil, err
					}
					cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
					cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
					cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
					cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
					nodeCpes = append(nodeCpes, models.Cpe{
						CpeBase: *cpeBase,
					})
				}
				for _, child := range node.Children {
					for _, cpe := range child.Cpes {
						if cpe.Vulnerable {
							cpeBase, err := parseCpeURI(cpe.Cpe22URI)
							if err != nil {
								return nil, err
							}
							cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
							cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
							cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
							cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
							nodeCpes = append(nodeCpes, models.Cpe{
								CpeBase: *cpeBase,
							})
						} else {
							if node.Operator == "AND" {
								for i, c := range nodeCpes {
									cpeBase, err := parseCpeURI(cpe.Cpe22URI)
									if err != nil {
										return nil, err
									}
									cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
									cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
									cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
									cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
									nodeCpes[i].EnvCpes = append(c.EnvCpes, models.EnvCpe{
										CpeBase: *cpeBase,
									})
								}
							}
						}
					}
				}
				cpes = append(cpes, nodeCpes...)
			}

			// Description
			descs := []models.Description{}
			for _, desc := range item.Cve.Description.DescriptionData {
				descs = append(descs, models.Description{
					Lang:  desc.Lang,
					Value: desc.Value,
				})
			}

			publish, err := parseNvdJSONTime(item.PublishedDate)
			if err != nil {
				return nil, err
			}
			modified, err := parseNvdJSONTime(item.LastModifiedDate)
			if err != nil {
				return nil, err
			}
			c2 := item.Impact.BaseMetricV2
			c3 := item.Impact.BaseMetricV3

			cve := models.CveDetail{
				CveID: item.Cve.CveDataMeta.ID,
				NvdJSON: &models.NvdJSON{
					CveID:        item.Cve.CveDataMeta.ID,
					Descriptions: descs,
					Cvss2: models.Cvss2Extra{
						Cvss2: models.Cvss2{
							VectorString:          c2.CvssV2.VectorString,
							AccessVector:          c2.CvssV2.AccessVector,
							AccessComplexity:      c2.CvssV2.AccessComplexity,
							Authentication:        c2.CvssV2.Authentication,
							ConfidentialityImpact: c2.CvssV2.ConfidentialityImpact,
							IntegrityImpact:       c2.CvssV2.IntegrityImpact,
							AvailabilityImpact:    c2.CvssV2.AvailabilityImpact,
							BaseScore:             c2.CvssV2.BaseScore,
							Severity:              c2.Severity,
						},
						ExploitabilityScore:     c2.ExploitabilityScore,
						ImpactScore:             c2.ImpactScore,
						ObtainAllPrivilege:      c2.ObtainAllPrivilege,
						ObtainUserPrivilege:     c2.ObtainUserPrivilege,
						ObtainOtherPrivilege:    c2.ObtainOtherPrivilege,
						UserInteractionRequired: c2.UserInteractionRequired,
					},
					Cvss3: models.Cvss3{
						VectorString:       c3.CvssV3.VectorString,
						AttackVector:       c3.CvssV3.AttackVector,
						AttackComplexity:   c3.CvssV3.AttackComplexity,
						PrivilegesRequired: c3.CvssV3.PrivilegesRequired,
						UserInteraction:    c3.CvssV3.UserInteraction,
						Scope:              c3.CvssV3.Scope,
						ConfidentialityImpact: c3.CvssV3.ConfidentialityImpact,
						IntegrityImpact:       c3.CvssV3.IntegrityImpact,
						AvailabilityImpact:    c3.CvssV3.AvailabilityImpact,
						BaseScore:             c3.CvssV3.BaseScore,
						BaseSeverity:          c3.CvssV3.BaseSeverity,
						ExploitabilityScore:   c3.ExploitabilityScore,
						ImpactScore:           c3.ImpactScore,
					},
					Cwes:             cwes,
					Cpes:             cpes,
					References:       refs,
					Affects:          affects,
					PublishedDate:    publish,
					LastModifiedDate: modified,
				},
			}
			cves = append(cves, cve)
		}
	}
	return
}

func chunkSlice(l []models.CveDetail, n int) chan []models.CveDetail {
	ch := make(chan []models.CveDetail)

	go func() {
		for i := 0; i < len(l); i += n {
			fromIdx := i
			toIdx := i + n
			if toIdx > len(l) {
				toIdx = len(l)
			}
			ch <- l[fromIdx:toIdx]
		}
		close(ch)
	}()
	return ch
}

func getCveIDs(item jvn.Item) []string {
	cveIDsMap := map[string]bool{}
	for _, ref := range item.References {
		switch ref.Source {
		case "NVD", "CVE":
			cveIDsMap[ref.ID] = true
		}
	}
	var cveIDs []string
	for cveID := range cveIDsMap {
		cveIDs = append(cveIDs, cveID)
	}
	return cveIDs
}

func stringToFloat(str string) float64 {
	if len(str) == 0 {
		return 0
	}
	var f float64
	var ignorableError error
	if f, ignorableError = strconv.ParseFloat(str, 64); ignorableError != nil {
		log.Errorf("Failed to cast CVSS score. score: %s, err; %s",
			str,
			ignorableError,
		)
		f = 0
	}
	return f
}

func parseCpeURI(cpe22uri string) (*models.CpeBase, error) {
	wfn, err := naming.UnbindURI(cpe22uri)
	if err != nil {
		return nil, err
	}

	return &models.CpeBase{
		URI:             naming.BindToURI(wfn),
		FormattedString: naming.BindToFS(wfn),
		WellFormedName:  wfn.String(),
		CpeWFN: models.CpeWFN{
			Part:            fmt.Sprintf("%s", wfn.Get(common.AttributePart)),
			Vendor:          fmt.Sprintf("%s", wfn.Get(common.AttributeVendor)),
			Product:         fmt.Sprintf("%s", wfn.Get(common.AttributeProduct)),
			Version:         fmt.Sprintf("%s", wfn.Get(common.AttributeVersion)),
			Update:          fmt.Sprintf("%s", wfn.Get(common.AttributeUpdate)),
			Edition:         fmt.Sprintf("%s", wfn.Get(common.AttributeEdition)),
			Language:        fmt.Sprintf("%s", wfn.Get(common.AttributeLanguage)),
			SoftwareEdition: fmt.Sprintf("%s", wfn.Get(common.AttributeSwEdition)),
			TargetSW:        fmt.Sprintf("%s", wfn.Get(common.AttributeTargetSw)),
			TargetHW:        fmt.Sprintf("%s", wfn.Get(common.AttributeTargetHw)),
			Other:           fmt.Sprintf("%s", wfn.Get(common.AttributeOther)),
		},
	}, nil
}

// convert string time to time.Time
// JVN : "2016-01-26T13:36:23+09:00",
// NVD : "2016-01-20T21:59:01.313-05:00",
func parseJvnTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04-07:00"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, fmt.Errorf("Failed to parse time, time: %s, err: %s",
			strtime, err)
	}
	return
}

func parseNvdJSONTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04Z"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, fmt.Errorf("Failed to parse time, time: %s, err: %s",
			strtime, err)
	}
	return
}
