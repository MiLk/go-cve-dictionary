package db

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/k0kubun/pp"
	jvn "github.com/kotakanbe/go-cve-dictionary/fetcher/jvn/xml"
	nvdjson "github.com/kotakanbe/go-cve-dictionary/fetcher/nvd/json"
	nvd "github.com/kotakanbe/go-cve-dictionary/fetcher/nvd/xml"
	log "github.com/kotakanbe/go-cve-dictionary/log"
	"github.com/kotakanbe/go-cve-dictionary/models"
)

// DB is interface for a database driver
type DB interface {
	Name() string
	CloseDB() error
	Get(string) (*models.CveDetail, error)
	GetMulti([]string) (map[string]*models.CveDetail, error)
	GetByCpeName(string) ([]*models.CveDetail, error)
	InsertJvn([]jvn.Item) error
	InsertNvd([]nvd.Entry) error
	InsertNvdJSON([]nvdjson.NvdJSON) error
	CountNvd() (int, error)
}

// NewDB return DB accessor.
func NewDB(dbType, dbpath string, debugSQL bool) (DB, error) {
	switch dbType {
	case dialectSqlite3, dialectMysql, dialectPostgreSQL:
		return NewRDB(dbType, dbpath, debugSQL)
	case dialectRedis:
		return NewRedis(dbType, dbpath, debugSQL)
	}
	return nil, fmt.Errorf("Invalid database dialect, %s", dbType)
}

// convertNvd converts Nvd structure(got from NVD) to model structure.
func convertNvd(entries []nvd.Entry) (cves []models.CveDetail, err error) {
	for _, entry := range entries {
		// References
		refs := []models.Reference{}
		for _, r := range entry.References {
			ref := models.Reference{
				Source: r.Source,
				Link:   r.Link.Href,
			}
			refs = append(refs, ref)
		}

		//  Cpes
		//TODO WFN, Vendor, Product, CPE22, CPE23
		cpes := []models.Cpe{}
		for _, c := range entry.Products {
			cpe, err := parseCpe(c)
			if err != nil {
				return nil, err
			}
			cpes = append(cpes, cpe)
		}

		cwes := []models.Cwe{}
		for _, cwe := range entry.Cwes {
			cwes = append(cwes, models.Cwe{
				CweID: cwe.ID,
			})
		}

		cve := models.CveDetail{
			CveID: entry.CveID,
			Nvd: &models.Nvd{
				CveID:   entry.CveID,
				Summary: entry.Summary,
				Cvss2: models.Cvss2{
					//TODO VectorString
					BaseScore:             stringToFloat(entry.Cvss.Score),
					AccessVector:          entry.Cvss.AccessVector,
					AccessComplexity:      entry.Cvss.AccessComplexity,
					Authentication:        entry.Cvss.Authentication,
					ConfidentialityImpact: entry.Cvss.ConfidentialityImpact,
					IntegrityImpact:       entry.Cvss.IntegrityImpact,
					AvailabilityImpact:    entry.Cvss.AvailabilityImpact,
				},
				Cwes:             cwes,
				PublishedDate:    entry.PublishedDate,
				LastModifiedDate: entry.LastModifiedDate,

				Cpes:       cpes,
				References: refs,
			},
		}
		cves = append(cves, cve)
	}
	return
}

// ConvertJvn converts Jvn structure(got from JVN) to model structure.
func convertJvn(items []jvn.Item) (cves []models.CveDetail, err error) {
	for _, item := range items {
		if item.Cvss.Score == "0" || len(item.Cvss.Score) == 0 {
			log.Debugf("Skip. CVSS Score is zero. JvnID: %s", item.Identifier)
			//ignore invalid item
			continue
		}

		//  References
		refs := []models.Reference{}
		for _, r := range item.References {
			ref := models.Reference{
				Source: r.Source,
				Link:   r.URL,
			}
			refs = append(refs, ref)
		}

		// Cpes
		//TODO WFN, Vendor, Product, CPE22, CPE23
		cpes := []models.Cpe{}
		for _, c := range item.CpeItem {
			cpe, err := parseCpe(c.Name)
			if err != nil {
				return nil, err
			}
			cpes = append(cpes, cpe)
		}

		publish, err := parseJvnTime(item.Issued)
		if err != nil {
			return nil, err
		}
		modified, err := parseJvnTime(item.Modified)
		if err != nil {
			return nil, err
		}

		cveIDs := getCveIDs(item)
		if len(cveIDs) == 0 {
			log.Debugf("No CveIDs in references. JvnID: %s, Link: %s",
				item.Identifier, item.Link)
			// ignore this item
			continue

		}

		for _, cveID := range cveIDs {
			cve := models.CveDetail{
				CveID: cveID,

				Jvn: &models.Jvn{
					CveID:   cveID,
					Title:   strings.Replace(item.Title, "\r", "", -1),
					Summary: strings.Replace(item.Description, "\r", "", -1),
					JvnLink: item.Link,
					JvnID:   item.Identifier,

					Cvss2: models.Cvss2{
						BaseScore:    stringToFloat(item.Cvss.Score),
						Severity:     item.Cvss.Severity,
						VectorString: item.Cvss.Vector,
						// TODO extract vectorstring to each fields
					},

					References: refs,
					Cpes:       cpes,

					PublishedDate:    publish,
					LastModifiedDate: modified,
				},
			}
			cves = append(cves, cve)
		}
	}
	return
}

// convertNvdJSON converts Nvd JSON to model structure.
func convertNvdJSON(nvds []nvdjson.NvdJSON) (cves []models.CveDetail, err error) {
	for _, nvd := range nvds {
		for _, item := range nvd.CveItems {

			//References
			refs := []models.Reference{}
			for _, r := range item.Cve.References.ReferenceData {
				ref := models.Reference{
					Link: r.URL,
				}
				refs = append(refs, ref)
			}

			// Cwes
			cwes := []models.Cwe{}
			for _, data := range item.Cve.Problemtype.ProblemtypeData {
				for _, desc := range data.Description {
					cwes = append(cwes, models.Cwe{
						CweID: desc.Value,
					})
				}
			}

			// Affects
			affects := []models.Affect{}
			for _, vendor := range item.Cve.Affects.Vendor.VendorData {
				for _, prod := range vendor.Product.ProductData {
					for _, version := range prod.Version.VersionData {
						affects = append(affects, models.Affect{
							VendorName:   vendor.VendorName,
							ProductName:  prod.ProductName,
							VersionValue: version.VersionValue,
						})
					}
				}
			}

			// Traverse Cpe, EnvCpe
			cpes := []models.Cpe{}
			for _, node := range item.Configurations.Nodes {
				if node.Negate {
					pp.Printf("Finally found Negate True!!!: %s", item.Cve.CveDataMeta.ID)
					continue
				}
				nodeCpes := []models.Cpe{}
				for _, child := range node.Children {
					for _, cpe := range child.Cpes {
						if cpe.Vulnerable {
							if child.Operator != "OR" {
								//TODO remove
								pp.Println("Amazing OR")
							}
							nodeCpes = append(nodeCpes, models.Cpe{
								Cpe22URI:              cpe.Cpe22URI,
								Cpe23URI:              cpe.Cpe23URI,
								VersionStartExcluding: cpe.VersionStartExcluding,
								VersionStartIncluding: cpe.VersionStartIncluding,
								VersionEndExcluding:   cpe.VersionEndExcluding,
								VersionEndIncluding:   cpe.VersionEndIncluding,
								//TODO Vendor, Product, WFN
							})
						} else {
							if child.Operator != "OR" {
								//TODO remove
								pp.Println("Amazing OR!!")
							}
							if node.Operator == "AND" {
								for i, c := range nodeCpes {
									nodeCpes[i].EnvCpes = append(c.EnvCpes, models.EnvCpe{
										Cpe22URI:              cpe.Cpe22URI,
										Cpe23URI:              cpe.Cpe23URI,
										VersionStartExcluding: cpe.VersionStartExcluding,
										VersionStartIncluding: cpe.VersionStartIncluding,
										VersionEndExcluding:   cpe.VersionEndExcluding,
										VersionEndIncluding:   cpe.VersionEndIncluding,
										//TODO Vendor, Product, WFN
									})
								}
							}
						}
					}
				}
				cpes = append(cpes, nodeCpes...)
			}

			// Description
			descs := []models.Description{}
			for _, desc := range item.Cve.Description.DescriptionData {
				descs = append(descs, models.Description{
					Lang:  desc.Lang,
					Value: desc.Value,
				})
			}

			publish, err := parseNvdJSONTime(item.PublishedDate)
			if err != nil {
				return nil, err
			}
			modified, err := parseNvdJSONTime(item.LastModifiedDate)
			if err != nil {
				return nil, err
			}
			c2 := item.Impact.BaseMetricV2
			c3 := item.Impact.BaseMetricV3

			cve := models.CveDetail{
				CveID: item.Cve.CveDataMeta.ID,
				NvdJSON: &models.NvdJSON{
					CveID:        item.Cve.CveDataMeta.ID,
					Descriptions: descs,
					Cvss2: models.Cvss2Extra{
						Cvss2: models.Cvss2{
							VectorString:          c2.CvssV2.VectorString,
							AccessVector:          c2.CvssV2.AccessVector,
							AccessComplexity:      c2.CvssV2.AccessComplexity,
							Authentication:        c2.CvssV2.Authentication,
							ConfidentialityImpact: c2.CvssV2.ConfidentialityImpact,
							IntegrityImpact:       c2.CvssV2.IntegrityImpact,
							AvailabilityImpact:    c2.CvssV2.AvailabilityImpact,
							BaseScore:             c2.CvssV2.BaseScore,
							Severity:              c2.Severity,
						},
						ExploitabilityScore:     c2.ExploitabilityScore,
						ImpactScore:             c2.ImpactScore,
						ObtainAllPrivilege:      c2.ObtainAllPrivilege,
						ObtainUserPrivilege:     c2.ObtainUserPrivilege,
						ObtainOtherPrivilege:    c2.ObtainOtherPrivilege,
						UserInteractionRequired: c2.UserInteractionRequired,
					},
					Cvss3: models.Cvss3{
						VectorString:       c3.CvssV3.VectorString,
						AttackVector:       c3.CvssV3.AttackVector,
						AttackComplexity:   c3.CvssV3.AttackComplexity,
						PrivilegesRequired: c3.CvssV3.PrivilegesRequired,
						UserInteraction:    c3.CvssV3.UserInteraction,
						Scope:              c3.CvssV3.Scope,
						ConfidentialityImpact: c3.CvssV3.ConfidentialityImpact,
						IntegrityImpact:       c3.CvssV3.IntegrityImpact,
						AvailabilityImpact:    c3.CvssV3.AvailabilityImpact,
						BaseScore:             c3.CvssV3.BaseScore,
						BaseSeverity:          c3.CvssV3.BaseSeverity,
						ExploitabilityScore:   c3.ExploitabilityScore,
						ImpactScore:           c3.ImpactScore,
					},
					Cwes:             cwes,
					Cpes:             cpes,
					References:       refs,
					Affects:          affects,
					PublishedDate:    publish,
					LastModifiedDate: modified,
				},
			}
			cves = append(cves, cve)
		}
	}
	return
}

func chunkSlice(l []models.CveDetail, n int) chan []models.CveDetail {
	ch := make(chan []models.CveDetail)

	go func() {
		for i := 0; i < len(l); i += n {
			fromIdx := i
			toIdx := i + n
			if toIdx > len(l) {
				toIdx = len(l)
			}
			ch <- l[fromIdx:toIdx]
		}
		close(ch)
	}()
	return ch
}

func getCveIDs(item jvn.Item) []string {
	cveIDsMap := map[string]bool{}
	for _, ref := range item.References {
		switch ref.Source {
		case "NVD", "CVE":
			cveIDsMap[ref.ID] = true
		}
	}
	var cveIDs []string
	for cveID := range cveIDsMap {
		cveIDs = append(cveIDs, cveID)
	}
	return cveIDs
}

func stringToFloat(str string) float64 {
	if len(str) == 0 {
		return 0
	}
	var f float64
	var ignorableError error
	if f, ignorableError = strconv.ParseFloat(str, 64); ignorableError != nil {
		log.Errorf("Failed to cast CVSS score. score: %s, err; %s",
			str,
			ignorableError,
		)
		f = 0
	}
	return f
}

// TODO move to jvn
// TODO use go-cpe
func parseCpe(cpeName string) (models.Cpe, error) {
	s := strings.Split(cpeName, "cpe:/")
	if len(s) != 2 {
		return models.Cpe{}, fmt.Errorf("Unknow format: cpeName: %s", cpeName)
	}
	splitted := strings.Split(s[1], ":")
	items := []string{
		"", // Part
		"", // Vendor
		"", // Product
		"", // Version
		"", // VendorUpdate
		"", // Edition
		"", // Language
	}
	for i, item := range splitted {
		items[i] = item
	}
	cpe := models.Cpe{
		Cpe22URI: cpeName,
	}
	return cpe, nil
}

// convert string time to time.Time
// JVN : "2016-01-26T13:36:23+09:00",
// NVD : "2016-01-20T21:59:01.313-05:00",
func parseJvnTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04-07:00"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, fmt.Errorf("Failed to parse time, time: %s, err: %s",
			strtime, err)
	}
	return
}

func parseNvdJSONTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04Z"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, fmt.Errorf("Failed to parse time, time: %s, err: %s",
			strtime, err)
	}
	return
}
